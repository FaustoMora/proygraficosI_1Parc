*Autores: Roberto Yonc&oacute;n, Kevin Filella, Pedro I&ntilde;iguez  
*T&iacute;tulo: Proyecto 2 Gr&aacute;ficos por Computadora - Primer T&eacute;rmino 2014 - 2015
<html>
	<head>
		<title> Graficos por Computadora </title>
		<style> canvas {
					width: 100%;
					height: 100%;
				} </style>
				
	</head>
	<body>
		<script src="js/libs/three.min.js"> </script>
		<script src="js/libs/TrackballControls.js"> </script>
		<script src="js/libs/dat.gui.js"></script>
		<script src="models/teapot.js"></script>
		<script>	
			//creación de la escena
			var scene = new THREE.Scene();
			//establecemos la cámara, el tipo de vista y sus dimensiones.
			var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
			//definimos un render
			var renderer = new THREE.WebGLRenderer();
			//render
			renderer.setClearColorHex(0x000000);
			renderer.setSize(window.innerWidth, window.innerHeight); //defino el tamaño de lo que vamos a renderizar
			document.body.appendChild(renderer.domElement);
			renderer.shadowMapEnabled = true; //habilito el calculo de sombras en el renderizado
			//plano
			var planeGeom = new THREE.PlaneGeometry(100, 100, 1, 1); //definimos un plano de dimensiones 60x60
		
			var planeMat = new THREE.MeshLambertMaterial({color: 0xFFFFFF});//definimos el color del plano
			var plane =new THREE.Mesh(planeGeom , planeMat); //creamos el plano juntando la textura con la forma para obtener nuestro objeto
			plane.receiveShadow = true; //habilitamos que proyecte sombra
			plane.rotation.x=-0.5*Math.PI;; //rotamos el plano
			plane.position.x=0//cambiamos la posición inicial del plano
			plane.position.y=0
			plane.position.z=0
			scene.add(plane);//agregamos el plano a la escena
			
			//cubo
			var cubeGeom = new THREE.CubeGeometry(3, 3, 3);//definimos las dimensiones del cubo x, y, z
			var cubeMat = new THREE.MeshLambertMaterial({color: 0xFF0000, shading: THREE.FlatShading}); //inicializamos una textura de color rojo
			var cube = new THREE.Mesh(cubeGeom, cubeMat);//juntamos la textura y la forma para obtener el objeto
			cube.castShadow = true;//habilitamos sombra
			cube.position.x=25;//definimos la posición inicial
			cube.position.y=10;
			cube.position.z=-15;
			var cub2Geom = new THREE.CubeGeometry(1, 1, 1);//definimos las dimensiones del cubo 2
			var cub2Mat = new THREE.MeshLambertMaterial({color: 0xFF000F, shading: THREE.FlatShading}); 
			var cub2 = new THREE.Mesh(cub2Geom, cub2Mat);
			cub2.castShadow = true;
			cub2.position.y=10;//definimos la posición inicial
			
			scene.add(cub2);//agregamos el cubo pequeño a la escena
			scene.add(cube);//añadimos el cubo a la escena
			//esfera
			var sphereGeom = new THREE.SphereGeometry(1, 20, 20); //Definimos las dimensiones de la esfera
			var sphereMat = new THREE.MeshLambertMaterial({color: 0x0000ff, shading: THREE.FlatShading});//inicializamos textura de color azul
			var sphere = new THREE.Mesh(sphereGeom, sphereMat);//las juntamos en una figura
			sphere.castShadow = true; //habilitamos la proyección de sombra
			sphere.position.x=0;//definimos la posición inicial
			sphere.position.y=10;
			sphere.position.z=0;
			var spher2Geom = new THREE.SphereGeometry(0.5, 20, 20); //Definimos la esferita
			var spher2Mat = new THREE.MeshLambertMaterial({color: 0x0f00ff, shading: THREE.FlatShading});
			var spher2 = new THREE.Mesh(spher2Geom, spher2Mat);
			spher2.castShadow = true; //habilitamos la proyección de sombra
			spher2.position.y =10;
			
			scene.add(sphere);//agregamos la esfera a la escena
			scene.add(spher2);//agregamos la esfera 2 a la escena
			//piramide
			var pyrGeom = new THREE.CylinderGeometry( 0, 3, 5, 4, 1 );//definimos las dimensiones de un cilindro, donde 4 representa el numero de puntos de la base y 0 representa n+1 puntos de la cara superior, obteniendo una pirámide de base cuadrada
			var pyrMat = new THREE.MeshLambertMaterial({color: 0x00ff00, shading: THREE.FlatShading}); //creamos una textura de color verde
			var pyr = new THREE.Mesh(pyrGeom, pyrMat);//juntamos las dimensiones geométricas con la textura
			pyr.castShadow = true;//habilitamos sombra
			pyr.position.x=-15;//definimos la posición inicial de la figura.
			pyr.position.y=10;
			pyr.position.z=-30;
			var pyr2Geom = new THREE.CylinderGeometry( 0, 1, 2, 4, 1 );//definimos las dimensiones de un cilindro pequeño
			var pyr2Mat = new THREE.MeshLambertMaterial({color: 0x0fff00, shading: THREE.FlatShading}); 
			var pyr2 = new THREE.Mesh(pyr2Geom, pyr2Mat);
			pyr.castShadow = true;//habilitamos sombra
			pyr2.position.y=10;//definimos la posición inicial de y.
			
			scene.add(pyr);//agregamos la pirámide a la escena
			scene.add(pyr2);//agregamos la pirámide 2 a la escena
			//toroide
			var toroGeom = new THREE.TorusGeometry(3, 1, 10, 10);//definimos las dimensiones de un toroide
			var toroMat = new THREE.MeshPhongMaterial({color: 0x00ffff, shading: THREE.FlatShading}); //creamos una textura color turquesa
			var toro = new THREE.Mesh(toroGeom, toroMat);//juntamos las propiedades geometricas con la textura
			toro.castShadow = true;//habilitamos sombra
			toro.position.x=7;//definimos la posición y rotación inicial del objeto.
			toro.position.y=10;
			toro.position.z=20;
			var tor2Geom = new THREE.TorusGeometry(1, 0.5, 10, 10);//definimos toroide pequeño
			var tor2Mat = new THREE.MeshLambertMaterial({color: 0x0fffff, shading: THREE.FlatShading}); 
			var tor2 = new THREE.Mesh(tor2Geom, tor2Mat);
			tor2.castShadow = true;//habilitamos sombra
			tor2.position.y=10;//definimos la posición y
			
			scene.add(toro);//añadimos el toroide a la escena
			scene.add(tor2);//añadimos el toroide 2 a la escena
			
			var teapot3D = new THREE.Object3D(); //creamos un wrapper para la tetera y así poder modificar sus atributos con un controlador
			var loader = new THREE.JSONLoader(); //utilizamos la funcion load de JSONLoader para cargar un modelo existente
			loader.load( "models/teapot.js", addTeapot );
			scene.add(teapot3D);//agregamos la tetera a la escena
			
			function addTeapot(geometry, materials) 
			{
				var material = new THREE.MeshPhongMaterial({ //utilizamos algunas variables disponibles para MeshPhongMaterial
					specular: '#ffff00', //luz especular
					color: '#ffff00', //color del objeto (amarillo)
					emissive: '#ff0000', //emision de luz. en este caso, un tono rojizo 
					shading: THREE.FlatShading, //shading de los triangulos de las superficies curvas
					wireframe: false, //muestra el modelo wireframe
					shininess: 100 //intensidad de brillo
				});
				mesh = new THREE.Mesh(geometry, material);//juntamos las propiedades geometricas con la textura
				mesh.traverse( function( node ) { if ( node instanceof THREE.Mesh ) { node.castShadow = true; } } );
				mesh.castShadow = true;
				mesh.position.x=0;
				mesh.position.y=10;
				mesh.position.z=0;
				teapot = mesh;
				teapot3D.add(teapot);//envolvemos la tetera en un objeto3D de THREE
				
			}

			
			//camara
			camera.position.x = 40;//definimos la posición para la cámara
			camera.position.y = 80;
			camera.position.z = 0;
			camera.lookAt(scene.position);//le decimos a la cámara que mire hacia la escena
			
			//luces
			var ambientLight = new THREE.AmbientLight(0x444444); //creamos una luz ambiental oscura
			scene.add(ambientLight);//la añadimos a la escena
			
			var spotLight = new THREE.SpotLight(0xffffff);//creamos una luz artificial 
			spotLight.position.set(0,110, 0); //definimos la posicion la de luz artificial
			spotLight.castShadow = true;//habilitamos que provoque sombra
			scene.add(spotLight);//la añadimos a la escena.
			
			var light1 = new THREE.PointLight(0xffffff, 10, 55); //creamos una luz de enfoque
			light1.position.set(50, 50, 50); //la colocamos en el punto (50, 50, 50)
			scene.add(light1);//la añadimos a la escena
			var light2 = new THREE.PointLight(0xffffff, 10, 55);//creamos otra luz de enfoque
			light2.position.set(-50, 50, 50);
			scene.add(light2);
			var light3 = new THREE.PointLight(0xffffff, 10, 55);//creamos otra luz de enfoque
			light3.position.set(50, 50, -50);
			scene.add(light3);
			var light4 = new THREE.PointLight(0xffffff, 10, 55);//creamos otra luz de enfoque
			light4.position.set(-50, 50, -50);
			scene.add(light4);
			
			
			//Variables a ser utilizadas por los controles
			var steps=4; //parametro de traslación de la esfera
			var stepc=3; //parametro de traslación del cubo
			var stepp=2; //parametro de traslación de la piramide
			var stept=1; //parametro de traslación del toroide
			
			//Controles
			var controls = new function() {
				//Serán funciones públicas con el valor inicial al momento de ejecutar el programa:
				//factor de rotación del CUBO
				this.traslationSpeedS = 0.2; //velocidad de traslación de la esfera
				this.rotationSpeedC = 0.2; //velocidad de rotacion sobre el eje del cubo
				this.traslationSpeedC = 0.2; //velocidad de traslación del cubo
				this.rotationSpeedP = 0.2; //velocidad de rotacion sobre el eje de la piramide
				this.traslationSpeedP = 0.2; //velocidad de traslación de la piramide
				this.rotationSpeedT = 0.2; //velocidad de rotacion sobre el eje del toroide
				this.traslationSpeedT = 0.2; //velocidad de traslación del toroide
				this.rotationSpeedTP = 0.2; //velocidad de rotacion de la tetera
				this.shadingType = 2;
				this.luz1 = false; //establesco variables que modifiquen el estado de la luz On/Off
				this.luz2 = false; //las inicializo como apagadas
				this.luz3 = false;
				this.luz4 = false;
			}
			//mouse tracking
			mouseTrack = new THREE.TrackballControls(camera, renderer.domElement); //función que modifica la camara segun el movimiento del mouse
			mouseTrack.rotateSpeed=0.8; //velocidad de rotacion de la cámara
			mouseTrack.zoomSpeed=1.5; //velocidad de acercamiento/alejamiento de la camara
			mouseTrack.panSpeed=1.0; //velocidad de traslación de la camara
			mouseTrack.noZoom=false;
			mouseTrack.noPan=false;
			mouseTrack.staticMoving=true;
			mouseTrack.dynamicDampingFactor = 0.3;
			
			window.addEventListener('resize', onWindowResize, false); //evento que ajusta la ventana de visualización
			//Inicialización de variable de controles
			var gui = new dat.GUI(); 
			
			//Folders para mejor presentación
			//Folder 1: ESFERA
			var f1Sphere = gui.addFolder('Sphere');
			f1Sphere.add(controls, 'traslationSpeedS',0,0.5);
			
			//Folder 2: CUBO
			var f2Cube = gui.addFolder('Cube');
			f2Cube.add(controls, 'traslationSpeedC',0,0.5);
			f2Cube.add(controls, 'rotationSpeedC',0,0.5);
			
			//Folder 3: TOROIDE
			var f3Toro = gui.addFolder('Toroid');
			f3Toro.add(controls, 'traslationSpeedT',0,1);
			f3Toro.add(controls, 'rotationSpeedT',0,0.5);
			
			//Folder 4: PIRÁMIDE
			var f4Pyr = gui.addFolder('Pyramid');
			f4Pyr.add(controls, 'rotationSpeedP',0,0.5);
			f4Pyr.add(controls, 'traslationSpeedP',0,1);
			
			//Folder 5: TETERA
			var f5Tet = gui.addFolder('Teapot');
			f5Tet.add(controls, 'rotationSpeedTP',0,0.5);
			
			//Folder 6: LUCES
			var luces = gui.addFolder('Luces');
			luces.add(controls, 'luz1');
			luces.add(controls, 'luz2');
			luces.add(controls, 'luz3');
			luces.add(controls, 'luz4');
			
			//función render
			var render =function() {
			
				sphere.position.x =10*(Math.cos(steps)); //modifico la posición x dela esfera
				sphere.position.z =10*(Math.cos(steps+Math.PI/2)); //la posición z de la esfera
				spher2.position.x =2.5*(Math.cos(steps*2))+sphere.position.x; //igual con la esferita segun la posicion de la esfera grande
				spher2.position.z =2.5*(Math.cos(2*steps+Math.PI/2))+sphere.position.z;
				
				cube.position.x =20*(Math.cos(stepc)); //misma distribución que en el caso de la esfera pero con el cubo
				cube.position.z =20*(Math.cos(stepc+Math.PI/2));
				cub2.position.x =3.5*(Math.cos(stepc*2.5))+cube.position.x;
				cub2.position.z =3.5*(Math.cos(2.5*stepc+Math.PI/2))+cube.position.z;
				
				pyr.position.x =30*(Math.cos(stepp)); //misma distribución que en el caso de la esfera pero con la piramide
				pyr.position.z =30*(Math.cos(stepp+Math.PI/2));
				pyr2.position.x =4.5*(Math.cos(stepp*1.5))+pyr.position.x;
				pyr2.position.z =4.5*(Math.cos(1.5*stepp+Math.PI/2))+pyr.position.z;
				
				toro.position.x =40*(Math.cos(stept)); //misma distribución que en el caso de la esfera pero con el toroide
				toro.position.z =40*(Math.cos(stept+Math.PI/2));
				tor2.position.x =5.5*(Math.cos(stept*4))+toro.position.x;
				tor2.position.z =5.5*(Math.cos(4*stept+Math.PI/2))+toro.position.z;
				
				steps+=0.2*controls.traslationSpeedS; //avanza la oscilación para la esfera
				stepc+=0.1*controls.traslationSpeedC; //avanza la oscilación para el cubo
				stepp+=0.05*controls.traslationSpeedP; //avanza la oscilación para la piramide
				stept+=0.025*controls.traslationSpeedT; //avanza la oscilación para el toroide
				
				pyr.rotation.y += controls.rotationSpeedP; //continuo rotando la piramide
				cube.rotation.y += controls.rotationSpeedC; //continuo rotando el cubo
				toro.rotation.y += controls.rotationSpeedT; //continuo rotando el toroide
				teapot3D.rotation.y += controls.rotationSpeedTP; //rotacion de tetera por medio del wrap de Objeto3D
				
				pyr2.rotation.y += 0.1; //roto la piramide pequeña
				cub2.rotation.y += 0.1; //continuo rotando el cubito
				tor2.rotation.y += 0.1; //continuo rotando el toroide pequeño
				
				if(controls.luz1==false){ //segun el estado del checkbox activo o no la luz 1
					light1.distance=1; 
				}else{
					light1.distance=55;
				}
				if(controls.luz2==false){ //segun el estado del checkbox activo o no la luz 2
					light2.distance=1;
				}else{
					light2.distance=55;
				}
				if(controls.luz3==false){ //segun el estado del checkbox activo o no la luz 3
					light3.distance=1;
				}else{
					light3.distance=55;
				}
				if(controls.luz4==false){ //segun el estado del checkbox activo o no la luz 4
					light4.distance=1;
				}else{
					light4.distance=55;
				}
				
				mouseTrack.update(); //refresco el tracking del mouse
				requestAnimationFrame(render); //llamo a renderizar
				renderer.render(scene, camera); //paso como parametros del render la escena y la camara
			}
			var onWindowResize=function(){
				camera.aspect = window.innterWidth/window.innerHeight; //refresco el tamaño de la imagen
				camera.updateProjectionMatrix(); //actualizo la matriz de proyeccion de la camara
				renderer.setSize(window.innerWidth, window.innerHeight); 
				mouseTrack.handleResize(); 
				render();
			}
			render(); //llamo al renderizado
			
		</script>
	</body>
</html>