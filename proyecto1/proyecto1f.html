<html>
	<head>
		<title> Graficos por Computadora </title>
		<style> canvas {
					width: 100%;
					height: 100%;
				} </style>
				
	</head>
	<body>
		<script src="js/libs/three.min.js"> </script>
		<script src="js/libs/dat.gui.js"></script>
		<script>	
		
			var scene = new THREE.Scene();
			
			var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			
			var renderer = new THREE.WebGLRenderer();
			//render
			renderer.setClearColorHex(0xEEEEEE);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			renderer.shadowMapEnabled = true;
			//plano
			var planeGeom = new THREE.PlaneGeometry(60, 60, 1, 1);
			var planeMat = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
			var plane =new THREE.Mesh(planeGeom , planeMat);
			plane.receiveShadow = true;
			plane.rotation.x=-0.5*Math.PI;
			plane.position.x=15
			plane.position.y=0
			plane.position.z=0
			scene.add(plane);
			
			//Crear un cubo de dimension 4x4x4 y agregarlo en el plano en la posicion (30,3,-15)
			var cubeGeom = new THREE.CubeGeometry(4, 4, 4);
			var cubeMat = new THREE.MeshLambertMaterial({color: 0xFF0000});
			var cube = new THREE.Mesh(cubeGeom, cubeMat);
			cube.castShadow = true;
			cube.position.x=30;
			cube.position.y=3;
			cube.position.z=-15;
			
			scene.add(cube);
			
			//Crear una esfera de radio=4 y segmentos horizontales/verticales=20
			//Se agrego la esfera en el plano en la posicion (20,0,2)
			var sphereGeom = new THREE.SphereGeometry(4, 20, 20);
			var sphereMat = new THREE.MeshLambertMaterial({color: 0x0000ff});
			var sphere = new THREE.Mesh(sphereGeom, sphereMat);
			sphere.castShadow = true;
			sphere.position.x=20;
			sphere.position.y=0;
			sphere.position.z=2;
			scene.add(sphere);
			
			//Se utilizo CylinderGeometry para armar la piramide utilizando sus 5 parametros, ya que una piramide es un subtipo de un cilindro.
			//Se creo un cilindro con radio superior en 0 para darle la forma de cono, radio inferior 5 y altura 10.
			//Numero de caras o segmentos = 4, para darle las cuatro caras caracteristicas de una piramide, y el ultimo parametro en 0 para crear la
			//cara inferior.
			//Se posiciono la piramide en (-15,5,-30) en el plano.
			var pyrGeom = new THREE.CylinderGeometry( 0, 5, 10, 4, 0);
			var pyrMat = new THREE.MeshLambertMaterial({color: 0x00ff00});
			var pyr = new THREE.Mesh(pyrGeom, pyrMat);
			pyr.castShadow = true;
			pyr.position.x=-15;
			pyr.position.y=5;
			pyr.position.z=-30;
			scene.add(pyr);
			
			//Se creo un toroide de radio 4, radio de tubo 2, 30 segmentos radiales y 50 segmentos del tubo.
			//Se posiciono el toroide en (7,5,20) en el plano con un factor de rotacion de 1/2(pi)
			var toroGeom = new THREE.TorusGeometry(4, 2, 30, 50);
			var toroMat = new THREE.MeshLambertMaterial({color: 0x00ffff});
			var toro = new THREE.Mesh(toroGeom, toroMat);
			toro.castShadow = true;
			toro.position.x=7;
			toro.position.y=5;
			toro.position.z=20;
			toro.rotation.x=0.5*Math.PI;
			scene.add(toro);
			
			//camara
			camera.position.x = -30;
			camera.position.y = 40;
			camera.position.z = 30;
			camera.lookAt(scene.position);
			
			//luces
			var ambientLight = new THREE.AmbientLight(0x0c0c0c);
			scene.add(ambientLight);
			
			var spotLight = new THREE.SpotLight(0xffffff);
			spotLight.position.set(-40, 60, -10);
			spotLight.castShadow = true;
			scene.add(spotLight);
			
			var step=0;
			
			//radius = sphereGeom.radius;
			var scale = 0; // adjust the multiplier to whatever
			
			//controles
			var controls = new function() {
				this.rotationSpeed = 0.02;
				this.bouncingSpeed = 0.03;
				this.scale = 0.5;
				this.distLength = 0.5;
				this.axisSelect = 1;
				this.rotationSpeedPyr = 0.02;
				this.rotationSpeedTor = 0.01;
			}

			var gui = new dat.GUI();
			
			//Se crearon carpetas para separar los controles de la esfera, cubo, piramide y toroide con el fin de mejorar la presentacion.
			var f1Sphere = gui.addFolder('Sphere');
			f1Sphere.add(controls, 'bouncingSpeed',0,0.5);
			f1Sphere.add(controls, 'distLength', 0,1);
			f1Sphere.add(controls, 'scale', 0.1,1);
			var f2Cube = gui.addFolder('Cube');
			f2Cube.add(controls, 'rotationSpeed',0,0.5);
			var f3Toro = gui.addFolder('Toroid');
			f3Toro.add(controls, 'axisSelect').options({'X Axis': 1, 'Y Axis': 2});
			f3Toro.add(controls, 'rotationSpeedTor',0,0.5);
			var f4Pyr = gui.addFolder('Pyramid');
			f4Pyr.add(controls, 'rotationSpeedPyr',0,0.5);
			
			//funcion render
			var render =function() {
				//rotacion del cubo
				cube.rotation.x += controls.rotationSpeed;
				cube.rotation.y += controls.rotationSpeed;
				cube.rotation.z += controls.rotationSpeed;
				
				//modificar distancia esfera
				//distLength: factor que permite modificar la distancia de rebote de la esfera.
				sphere.position.x = 20+( 20*(Math.cos(step)))*controls.distLength;
				sphere.position.y = 2 +( 10*Math.abs(Math.sin(step)));
				//rebote esfera
				step+=controls.bouncingSpeed;
				//scale: Controlador de escalamiento de la esfera (controlador del radio).
				sphere.scale.x = controls.scale;
				sphere.scale.y = controls.scale;
				sphere.scale.z = controls.scale;
				
				//rotationSpeedPyr: controlador de velocidad de rotacion de la piramide.
				pyr.rotation.y += controls.rotationSpeedPyr;
				
				//axisSelect: Selector de eje de rotacion del toroide
				//Se adiciona el valor de rotationSpeedTor*Pi para controlar la velocidad de rotacion del toroide.
				if (controls.axisSelect == 1){
					toro.rotation.x+=controls.rotationSpeedTor*Math.PI;
				} else if (controls.axisSelect == 2){
					toro.rotation.y+=controls.rotationSpeedTor*Math.PI;
				}
				
				requestAnimationFrame(render);
				renderer.render(scene, camera);
			}
			
			render();
			
		</script>
	</body>
</html>